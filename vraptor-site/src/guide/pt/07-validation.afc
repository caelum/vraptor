[chapter Validação]
O VRaptor3 suporta 2 estilos de validação. Clássico e fluente. A porta de entrada para ambos os estilos é o objeto Validator.
Para que seu recurso tenha acesso ao Validator, basta recebê-lo no construtor do seu recurso:

[java]
import br.com.caelum.vraptor.Validator;
...

@Resource
class FuncionarioController {
	private Validator validator;
	
	public FuncionarioController(Validator validator) {
		this.validator = validator;
	}
}
[/java]

[section Estilo clássico]

A forma clássica é semelhante a forma como as validações eram feitas no VRaptor2.
Dentro da sua lógica de negócios, basta fazer a verificação que deseja e caso haja um erro de validação, adicionar esse erro na lista de erros de validação.
Por exemplo, para validar que o nome do funcionario deve ser Fulano, faça:

[java]
public void adiciona(Funcionario funcionario) {
	if(! funcionario.getNome().equals("Fulano")) {
		validator.add(new ValidationMessage("erro","nomeInvalido"));
	}
	validator.onErrorUse(page()).of(FuncionarioController.class).formulario();
	dao.adiciona(funcionario);
}
[/java]

Ao chamar o validator.onErrorUse, se existirem erros de validação, o VRaptor para a execução e redireciona a
página que você indicou. O redirecionamento funciona da mesma forma que o result.use(..).

[section Estilo fluente]

No estilo fluente, a idéia é que o código para fazer a validação seja algo muito parecido com a linguagem natural.
Por exemplo, caso queiramos obrigar que seja informado o nome do funcionario:

[java]
public adiciona(Funcionario funcionario) {
	validator.checking(new Validations(){{
		that(!funcionario.getNome().isEmpty(), "erro","nomeNaoInformado");
	}})
	validator.onErrorUse(page()).of(FuncionarioController.class).formulario();
	
	dao.adiciona(funcionario);
}
[/java]

Você pode ler esse código como: "Validador, cheque as minhas validações. 
A primeira validação é que o nome do funcionário não pode ser vazio".
Bem mais próximo a linguagem natural.

Assim sendo, caso o nome do funcionario seja vazio, ele vai ser redirecionado novamente para a logica "formulario", 
que exibe o formulario para que o usuário adicione o funcionário novamente. Além disso, ele devolve para o formulario a mensagem de erro que aconteceu na validação.

Muitas vezes algumas validações só precisam acontecer se uma outra deu certo, por exemplo, eu só vou
checar a idade do usuário se o usuário não for null. O método that retorna um boolean dizendo se o que
foi passado pra ele é válido ou não:

[java]
	validator.checking(new Validations(){{
		if (that(usuario != null, "usuario", "usuario.nulo")) {
			that(usuario.getIdade() >= 18, "usuario.idade", "usuario.menor.de.idade");
		}
	}})
[/java]

Desse jeito a segunda validação só acontece se a primeira não falhou.

[session Validação usando matchers do Hamcrest]
Você pode também usar matchers do Hamcrest para deixar a validação mais legível, e ganhar
a vantagem da composição de matchers e da criação de novos matchers que o Hamcrest te oferece:
[java]
public adiciona(Funcionario funcionario) {
	validator.checking(new Validations(){{
		that(funcionario.getNome(), not(emptyString()), "erro","nomeNaoInformado");
	}})
	validator.onErrorUse(page()).of(FuncionarioController.class).formulario();	
	dao.adiciona(funcionario);
}
[/java]


[section Hibernate validator]

O VRaptor também suporta integração com o HibernateValidator. No exemplo anterior para validar o objeto Funcionario 
usando o Hibernate Validator basta adicionar uma linha de código:

[java]
public adiciona(Funcionario funcionario) {
	validator.checking(new Validations(){{
		that(!funcionario.getNome().isEmpty(), "erro","nomeNaoInformado");
		
		//Validação do Funcionario com Hibernate Validator
		and(Hibernate.validate(funcionario));
	}})
	
	dao.adiciona(funcionario);
}
[/java]

[section Para onde redirecionar no caso de erro]

Outro ponto importante que deve ser levado em consideração no momento de fazer validações é o 
redirecionamento quando ocorrer um erro. Como enviamos o usuário para outro recurso com o VRaptor3, 
caso haja erro na validação?

Simples, apenas diga no seu código que quando correr um erro, é para o usuário ser enviado para algum recurso.
Como no exemplo:

[java]
public adiciona(Funcionario funcionario) {
	//Validação na forma fluente
	validator.checking(new Validations(){{
		that("erro","nomeNaoInformado", !funcionario.getNome().isEmpty());
	}})
	//Validação na forma clássica
	if(! funcionario.getNome().equals("Fulano")) {
		validator.add(new ValidationMessage("erro","nomeInvalido"));
	}
	::validator.onErrorUse(page()).of(FuncionarioController.class).formulario();::
	
	dao.adiciona(funcionario);
}
[/java]

Note que se sua lógica adiciona algum erro de validação você **precisa** dizer pra onde o VRaptor deve ir.
O validator.onErrorUse funciona do mesmo jeito que o result.use: você pode usar qualquer view da
classe Results.
