[chapter Injeção de dependências]

O Vraptor está fortemente baseado no conceito de injeção de dependências uma vez que chega até mesmo a
utilizar dessa idéia para juntar seus componentes internos.

O conceito básico por trás de Dependency Injection (DI) é que você não deve buscar aquilo que deseja acessar
mas tudo o que deseja acessar deve ser fornecido para você.

Isso se traduz, no Java contemporâneo, a passagem de componentes através do construtor de seus controladores.
Imagine que seu controlador de clientes necessita acessar um Dao de clientes. Sendo assim, especifique claramente
essa necessidade:

[java]
@Component
public class ClienteController {
	private final ClienteDao dao;
	
	public ClienteController(ClienteDao dao) {
		this.dao = dao;
	}

	@Post
	public void adiciona(Cliente cliente) {
		this.dao.adiciona(cliente);
	}
	
}
[/java]

E anote também o componente ClienteDao como sendo controlado pelo vraptor:

[java]
@Component
public class ClienteDao {
}
[/java]

A partir desse instante, o vraptor fornecerá uma instância de ClienteDao para seu ClienteController
sempre que precisar instanciá-lo. Vale lembrar que o VRaptor honrará o escopo de cada componente.
Por exemplo, se ClienteDao fosse de escopo Session (@SessionScoped), seria criada uma única instância desse
componente por sessão. (note que é provavelmente errado usar um dao no escopo de session, isto é um mero exemplo).

[section ComponentFactory]

Em diversos momentos queremos que nossos componentes recebam componentes de outras bibliotecas.
Nesse caso não temos como alterar o código fonte da biblioteca para adicionar a anotação @Component (além de possíveis
alterações requeridas na biblioteca).

O exemplo mais famoso envolve adquirir uma Session do Hibernate. Nesses casos precisamos criar um componente
que possui um único papel: fornecer instâncias de Session para os componentes que precisam dela.

O VRaptor possui uma interface chamada ComponentFactory que permite que suas classes possuam tal responsabilidade.
Implementações dessa interface definem um único método. Veja o exemplo a seguir, que inicializa o Hibernate na construção
e utiliza essa configuração para fornecer sessões para nosso projeto:

[java]
@Component
@ApplicationScoped
public class SessionFactoryProvider implements ComponentFactory<SessionFactory> {

	private final SessionFactory factory;
	
	public SessionProvider() {
		factory = new AnnotationConfiguration().configure();
	}
	
	public SessionFactory getInstance() {
		return factory;
	}
	
}

@Component
@RequestScoped
public class SessionProvider implements ComponentFactory<Session> {

	private final SessionFactory factory;
	
	public SessionProvider(SessionFactory factory) {
		this.factory = factory;
	}
	
	public Session getInstance() {
		return factory.openSession();
	}
	
}
[/java]

[section Providers]
Por trás dos panos, o VRaptor utiliza um provider de DI específico. Por padrão o vraptor vêm com suporte ao uso interno
do Picocontainer ou do Spring DI.

Cada implementação disponibiliza tudo o que você encontra na documentação do vraptor, mas acaba por fornecer também pontos de extensão diferentes, claro.

[section Pico Container]

Ao utilizar o Picocontainer por baixo do VRaptor, você poderá acessar o pico diretamente para fazer configurações avançadas que desejar.

Para utilizar o Picocontainer como provider de sua aplicação, basta colocar no seu arquivo web.xml:

[xml]
		<context-param>
        <param-name>br.com.caelum.vraptor.provider</param-name>
        <param-value>br.com.caelum.vraptor.ioc.pico.PicoProvider</param-value>
    </context-param>
[/xml]



[section Spring]

Ao utilizar o Spring, você ganha todas as características e componentes prontos do Spring para uso dentro do VRaptor, isto é, todos os componentes que funcionam com o Spring DI/Ioc, funcionam com o VRaptor. Nesse caso, todas as anotações.

Para utilizar o Spring como provider de sua aplicação, basta colocar no seu arquivo web.xml, lembrando
que se você não especificar nenhum Provider o Spring é o padrão:


[xml]
		<context-param>
        <param-name>br.com.caelum.vraptor.provider</param-name>
        <param-value>br.com.caelum.vraptor.ioc.spring.SpringProvider</param-value>
    </context-param>

    <context-param>
        <param-name>br.com.caelum.vraptor.spring.packages</param-name>
        <param-value>br.com.pacote.do.seu.projeto</param-value>
    </context-param>
[/xml]

Se você tiver um applicationContext.xml no classpath o VRaptor vai aproveitar suas configurações.

[section Spring exemplo com Hibernate dele]


???????????

[section Seu próprio provider]

Você também pode criar seu próprio Provider, seja para adicionar novas características avançadas a implementação do Picocontainer ou do Spring, ou ainda para se basear em outro contâiner de DI que seja de sua preferência.
