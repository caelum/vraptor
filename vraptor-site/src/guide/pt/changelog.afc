[chapter ChangeLog]

[section 3.1 (a ser lançado)]
[list]
* agora é possível serializar coleções usando result.use(xml()) e result.use(json())
* novo escopo @PrototypeScoped, que cria sempre uma nova instância da classe anotada cada vez que
ela for requisitada.
* nova view: result.use(Results.representation()).from(objeto).serialize();
Essa view tenta descobrir o formato da requisição (via _format ou o header Accept) e renderizar o objeto
dado nesse formato. Por enquanto apenas xml e json são suportados, mas é possível criar serializadores
para qualquer formato. Se o formato não foi passado ou ele não é suportado, o jsp padrão vai ser mostrado.
* bugfix: os parâmetros agora são passados via array no escopo Flash, então tudo vai funcionar como 
 deveria no GAE
* bugfix: agora o validator.onErrorUse(...) funciona com todos os Results padrão.
* bugfix: retornar um Download/File/InputStream null não dá mais NullPointerException se já houve algum 
  redirecionamento (result.use(...)).
* bugfix: result.use(page()).redirect("...") agora inclui o contextPath se a url começar com /
* bugfix: agora é possível criar Controllers genéricos:
[java]
 public class ClientesController extends GenericController<Cliente> {
 
 }
 public class GenericController<T> {
    public T mostra(Long id) {...} // a variável da view vai se chamar t
    public void adiciona(T obj) {...} // os parâmetros da requisição vão ser obj.campo 
 }
[/java]
* você pode anotar sua classe controller com @Path, e todas as URIs dos métodos vão incluir o prefixo 
especificado.
  
[java]
@Resource
@Path("/prefixo")
public class MeuController {
	//URI: /prefixo/umMetodo
	public void umMetodo() {...}
	
	//URI: /prefixo/relativo
	@Path("relativo")
	public void pathRelativo() {...}

	//URI: /prefixo/absoluto
	@Path("/absoluto")
	public void pathAbsoluto() {...}
}
[/java]

* @Path agora aceita regexes: %%@Path("/abc/{abc:a+b+c+}")%% vai aceitar as URIs do tipo:
[code]
/abc/abc
/abc/aaaaabbcccc
/abc/abbc
[/code]
ou seja, onde o parâmetro casa com a regex %%a+b+c+%%

* Foram criados atalhos na interface %%Result%% para as operações mais comuns:
	[list]
	* result.forwardTo("/uma/uri") ==> result.use(page()).forward("/uma/uri");
	* result.forwardTo(ClienteController.class).lista() ==> result.use(logic()).forwardTo(ClienteController.class).lista();
	* result.redirectTo(ClienteController.class).lista() ==> result.use(logic()).redirectTo(ClienteController.class).lista();
	* result.of(ClienteController.class).lista() ==> result.use(page()).of(ClienteController.class).lista();
	[/list]
  Além disso, se o redirecionamento é para um método do mesmo controller, você pode usar:
  	[list]
  	* result.forwardTo(this).lista() ==> result.use(logic()).forwardTo(this.getClass()).lista();
	* result.redirectTo(this).lista() ==> result.use(logic()).redirectTo(this.getClass()).lista();
	* result.of(this).lista() ==> result.use(page()).of(this.getClass()).lista();
  	[/list]
* Se o base package não é configurado no web.xml, VRaptor scaneia por componentes e recursos em todo WEB-INF/classes
* Suporte a Servlet 3.0, fazendo desnecessário configurar o filtro no web.xml (usando recurso de webfragments)
* Jars do spring atualizados (3.0.0) e do hibernate também, para os projetos de exemplo.
* Blank project atualizado para WTP mais novo e refletindo novidades do VR 3.1
[/list]

[section 3.0.2]
[list]
* suporte a containers servlet 2.4, como Oracle Container 10.1.3.1
* bugfix: Results.referer() agora implementa View
* bugfix: content-type agora é exposto pelo File/InputStream Download
* removida chamadas a api de Java 6
* novos providers, baseados no Spring: HibernateCustomProvider e JPACustomProvider. 
  Esses providers já registram os componentes opcionais do Hibernate ou da JPA.
* bugfix: os converters agora não jogam exceções quando não existe um ResourceBundle configurado.
* bugfix: o retorno do método agora é incluido no result quando acontece um forward.
* bugfix: os parâmetros da requisição são mantidos quando acontece um erro de validação. 
* bugfix: lançando exceção quando o paranamer não consegue achar os metadados dos parâmetros,
assim é possível se recuperar desse problema.
* suporte inicial a serialização de objetos em xml e json:
[java]
  result.use(Results.json()).from(meuObjeto).include(...).exclude(...).serialize();
  result.use(Results.xml()).from(meuObjeto).include(...).exclude(...).serialize();
[/java]
[/list]

[section 3.0.1]
[list]
* paranamer atualizado para versão 1.5 (Atualize seu jar!)
* jars separados em opcional e obrigatório no vraptor-core
* dependências estão explicadas no vraptor-core/libs/mandatory/dependencies.txt e no 
  vraptor-core/libs/optional/dependencies.txt
* possibilidade de setar o character encoding da aplicação no web.xml através do context-param
	br.com.caelum.vraptor.encoding
* nova view: Referer view:
  result.use(Results.referer()).redirect();
* Escopo Flash:
  [java]
  result.include("umaChave", umObjeto);
  result.use(logic()).redirectTo(UmController.class).umMetodo();
  [/java]
  objetos incluidos no Result vão sobreviver até a próxima requisição quando acontecer um
  redirect.
* @Path suporta vários valores (String -> String[]) ex @Path({"/client", "/Client"})
* Result.include agora retorna this para uma interface fluente (result.include(...).include(....))
* Melhor mensagem de exception quando não encontra o Http method requisitado  
* File Download registra automaticamente content-length.
* Bug 117 resolvido: expondo null quando retorna null (anter era "ok")
* Bug 109 resolvido: se você tem um arquivo %%/caminho/index.jsp%%, você consegue acessá-lo agora via
	%%/caminho/%%, a menos que exista algum controller que trata essa URI
* Quando existe uma rota que consegue tratar a URI da requisição, mas que não aceita o HTTP method da requisição,
  o VRaptor vai retornar um HTTP status code 405 -> Method Not Allowed, ao invés do 404.
* Uma grande refatoração na API interna de rotas
[/list]

[section 3.0.0]
[list]
* ValidationError foi renomeado para ValidationException
* result.use(Results.http()) para setar headers e status codes do protocolo HTTP
* Correção de bugs
* documentação
* novo site
[/list]

[section 3.0.0-rc-1]
[list]
* aplicação de exemplo: mydvds
* novo jeito de adicionar os componentes opcionais do VRaptor:
[java]
public class CustomProvider extends SpringProvider {
	
	@Override
	protected void registerCustomComponents(ComponentRegistry registry) {
		registry.registry(ComponenteOpcional.class, ComponenteOpcional.class);
	}
}
[/java]

* Utils: HibernateTransactionInterceptor e JPATransactionInterceptor
* Um exemplo completo de aplicação na documentação.
* Docs em inglês
[/list]
[section 3.0.0-beta-5]
[list]
* Novo jeito de fazer validações:
  [java]
  	public void visualiza(Cliente cliente) {
  		validator.checking(new Validations() {{
  			that(cliente.getId() != null, "id", "id.deve.ser.preenchido");
  		}});
  		validator.onErrorUse(page()).of(ClientesController.class).list();
  		
  		//continua o metodo
  	}
  [/java]
* UploadedFile.getFile() agora retorna InputStream.
* EntityManagerCreator e EntityManagerFactoryCreator
* bugfixes

[/list]
[section 3.0.0-beta-4]
[list]
* Novo result: result.use(page()).of(MeuController.class).minhaLogica() renderiza a view
	padrão (/WEB-INF/jsp/meu/minhaLogica.jsp) sem executar a minhaLogica.
*	Classes Mocks para testes: MockResult e MockValidator, para facilitar testes unitários
	das lógicas. Eles ignoram a maioria das chamadas e guardam parâmetros incluídos no result
	e erros de validação.
*	As URIs passadas para result.use(page()).forward(uri) e result.use(page()).redirect(uri)
	não podem ser URIs de lógicas, usem os forwards e redirects do result.use(logic())
*	Os parâmetros passados para as URIs agora aceitam pattern-matching:
	[list]
	* Automático: se temos a URI /clients/{client.id} e client.id é um Long, o parâmetro {client.id} 
		só vai casar com números, ou seja, a URI /clients/42 casa, mas a uri /clients/random não casa.
		Isso funciona para todos os tipos numéricos, booleanos e enums, o vraptor vai restringir para
		os valores possíveis.
	* Manual: no CustomRoutes você vai poder fazer:
		routeFor("/clients/{client.id}").withParameter("client.id").matching("\\d{1,4}")
  			.is(ClienteController.class).mostra(null);
  	ou seja, pode restringir os valores para o determinado parâmetro via expressões regulares
  	no método matching.
  [/list]
* Converters para LocalDate e LocalTime do joda-time já vêm por padrão.
* Quando o Spring é usado como IoC Provider, o VRaptor tenta buscar o spring da aplicação para
	usar como container pai. A busca é feita por padrão em um dos dois jeitos:
	[list]
	* WebApplicationContextUtils.getWebApplicationContext(servletContext), para o caso em que você
		tem os listeners do Spring configurados.
	* applicationContext.xml dentro do classpath
	[/list]
	Se isso não for o suficiente você pode implementar a interface SpringLocator e disponbilizar
	o ApplicationContext do spring usado pela sua aplicação.
*	Utils:
	[list]
	* SessionCreator e SessionFactoryCreator para disponbilizar a Session e o SessionFactory do hibernate
		para os componentes registrados.
	* EncodingInterceptor, para mudar o encoding da sua aplicação.
	[/list]
* correção de vários bugs e melhorias na documentação.
[/list]
[section 3.0.0-beta-3]
[list]
* O Spring é o Provider de IoC padrão
* o applicationContext.xml no classpath é usado como configuração incial do spring, caso exista.
* a documentação http://vraptor.caelum.com.br/documentacao está mais completa e atualizada
* pequenos bugs e otimizações
[/list]
