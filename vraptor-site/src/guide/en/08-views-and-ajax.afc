[chapter View and Ajax]

[section Custom PathResolver]
By default, VRaptor tries to render your views following the convention:

[java]
	public class ClientsController {
		public void list() {
			//...
		}
	}
[/java]

The method listed above will render the view %%/WEB-INF/jsp/clients/list.jsp%%.

However, we don't always want it to behave that way, specially if we need to use some
template engine like Freemarker or Velocity. In that case, we need to change the convention.

An easy way of changing that convention is extending the %%DefaultPathResolver%% class:

[java]
	@Component
	public class FreemarkerPathResolver extends DefaultPathResolver {
		protected String getPrefix() {
			return "/WEB-INF/freemarker/";
		}
		
		protected String getExtension() {
			return "ftl";
		}
	}
[/java]

That way, the logic would try to render the view %%/WEB-INF/freemarker/clients/list.ftl%%.
If that solution is not enough, you can implement the %%PathResolver%% interface and do whatever convention you wish.
Don't forget to annotate your new classe with %%@Component%%.

[section View]
If you want to change a specific logic's view, you can use the %%Result%% object:

[java]
	@Resource
	public class ClientsController {
		
		private final Result result;
		
		public ClientsController(Result result) {
			this.result = result;
		}
		
		public void list() {}
		
		public void save(Client client) {
			//...
			this.result.use(Results.logic()).redirectTo(ClientsController.class).list();
		}
	}
[/java]

By default, there are these view implementations:

[list]
	* Results.logic(), redirects to any other logic in the application.
	* Results.page(), redirects directly to a page, that can be a jsp, an html, or any
	URI relative to the web application directory or the application context.
	* Results.http(), sends HTTP protocol informations, like status codes and headers.
	* Results.referer(), uses Referer header to redirect or forward.
	* Results.nothing(), simply returns the HTTP success code (HTTP 200 OK).
	* Results.xml(), uses xml serialization.
	* Results.json(), uses json serialization.
[/list]

[section Redirect and forward]
In VRaptor3, you can either redirect or forward the user to another logic or page.
The main difference between redirecting and forwarding is that the former happens
at client side, while the latter happens at server side.

A good redirect use is the pattern 'redirect-after-post', for example, when you add
a client and you want to return to the client listing page, but you want to avoid
the user to accidentally resend all data by refreshing (F5) the page.

An example of forwarding is when you have some data validation that fails, usually you
want the user to remain on the form with all the previously filled data.

[box Automatic Flash Scope]
If you add objects on Result and redirects to another logic, these objects will be available
on the next request.

[java]
public void add(Client client) {
	dao.add(client);
	result.include("notice", "Client successfully added");
	result.use(logic()).redirectTo(ClientsController.class).list();
}
[/java]

list.jsp:
[xml]
...
<div id="notice">
   <h3>${notice}</h3>
</div>
...
[/xml]

[/box]


[section Accepts and the _format parameter]
Many times you need to render different formats for the same logic. For example,
we want to return a JSON object instead of an HTML page.
In order to do that, we can define the request's Accepts header to accept the desired
format, or we can pass a %%_format%% paramenter in the request.

If the specified format is JSON, the default rendered view will be: %%/WEB-INF/jsp/{controller}/{logic}.json.jsp%%,
which means, in general, the rendered view will be: %%/WEB-INF/jsp/{controller}/{logic}.{format}.jsp%%.
If the format is HTML, then you won't need to specify it in the file name.

The %%_format%% parameter has a higher priority over the Accepts header.

[section Ajax: building on the view]
In order to return a JSON object to the view, your logic must make that object available somehow.
Just like the following example, your %%/WEB-INF/jsp/clients/load.json.jsp%%:
 
[code]
{ name: '${client.name}', id: '${client.id}' }
[/code]

And in the controller:

[java]
	@Resource
	public class ClientsController {
		
		private final Result result;
		private final ClientDao dao;
		
		public ClientsController(Result result, ClientDao dao) {
			this.result = result;
			this.dao = dao;
		}
		
		public void load(Client client) {
			result.include("client", dao.load(client));
		}
	}
[/java]

[section Ajax: Programatic version]

If you want that VRaptor automatically serializes your objects into xml or json, you can use
on your logic:
[java]
	import static br.com.caelum.vraptor.view.Results.*;
	@Resource
	public class ClientsController {
		
		private final Result result;
		private final ClientDao dao;
		
		public ClientsController(Result result, ClientDao dao) {
			this.result = result;
			this.dao = dao;
		}
		
		public void loadJson(Client client) {
			result.use(json()).from(client).serialize();
		}
		public void loadXml(Client client) {
			result.use(xml()).from(client).serialize();
		}
	}
[/java]

The results will be like:

[code]
{"client": {
	"name": "John"
}}
[/code]
[code]
<client>
	<name>John</name>
</client>
[/code]

By default, only fields with primitive types will be serialized (String, numbers, enums, dates),
if you want to include a field of a non-primitive type you must explicitly include it:

[java]
	result.use(json()).from(client).include("address").serialize();
[/java]

will result in something like:

[code]
{"client": {
	"name": "John",
	"address" {
		"street": "First Avenue"
	}
}}
[/code]

You can also exclude primitive fields from serialization:
[java]
	result.use(json()).from(user).exclude("password").serialize();
[/java]

will result in something like:

[code]
{"user": {
	"name": "John",
	"login": "john"
}}
[/code]

The default implementation is based on XStream, so you can configure the serialization
with annotations and direct configuration on XStream. It is just creating a class like:
[code]
@Component
public class CustomXMLSerialization extends XStreamXMLSerialization {
//or public class CustomJSONSerialization extends XStreamJSONSerialization {
	//delegate constructor
	
	@Override
	protected XStream getXStream() {
		XStream xStream = super.getXStream();
		//your xStream setup here
		return xStream;
	}
}
[/code]