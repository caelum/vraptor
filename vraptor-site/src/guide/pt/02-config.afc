[chapter Configuração básica]

As configurações necessárias para usar o VRaptor 3 são mínimas, só é essencial a
definição de um filtro no %%web.xml%%. Aqui veremos também algumas configurações
extras, que são opcionais.

[section web.xml]

No %%web.xml%% precisamos apenas adicionar o filtro do VRaptor3, da seguinte forma:

[xml]
<?xml version="1.0" encoding="UTF-8"?>
<web-app id="WebApp_ID" version="2.4"
         xmlns="http://java.sun.com/xml/ns/j2ee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd">

	<!-- declaracao do filtro -->
	<filter>
		<filter-name>vraptor</filter-name>
		<filter-class>br.com.caelum.vraptor.VRaptor</filter-class>
	</filter>

	<!-- mapeando o filtro para todas as requisicoes -->
	<filter-mapping>
		<filter-name>vraptor</filter-name>
		<url-pattern>/*</url-pattern>
		<dispatcher>FORWARD</dispatcher>
		<dispatcher>REQUEST</dispatcher>
	</filter-mapping>
</web-app>
[/xml]

Essa configuração do filtro do VRaptor fará com que todas as requisições que chegarem para sua aplicação sejam interpretadas pelo próprio VRaptor,
e dessa forma, ele poderá decidir para qual recurso o fluxo da sua aplicação será direcionado. E consequentemente, executando as lógicas de 
negócio que você definiu em sua aplicação. 

[section Seu recurso]

Cada recurso no VRaptor3 funciona como uma classe na qual você escreve suas lógicas de negócio e que ficam acessíveis para o usuário a partir de
uma determinada URI. Ao final da execução de cada lógica do seu recurso, o usuário é enviado para uma página que exibe o resultado final do processo.

Para escrever um recurso simples no VRaptor3, nós não precisamos de muito esforço, basta criarmos uma classe e anotarmos essa classe com a anotação
::@Resource::

[code]
@Resource
public class FuncionarioController {

	public List<Funcionario> listaTodos() {
		return ...
	}
	
	public void adiciona(Funcionario funcionario) {
	}
}
[/code]

No exemplo acima, FuncionarioController é um recurso, e os métodos listaTodos e adiciona são as lógicas.

[section Arquivo de mensagens]

Internacionalização (i18n) é um recurso poderoso, e que está presente em quase todos os frameworks web hoje em dia. E não é diferente no VRaptor3.
Com i18n podemos fazer com que nossa aplicação suporte várias línguas (francês, português, espanhol, inglês etc) de uma maneira que não nos
cause muito esforço, bastando apenas fazermos a tradução das mensagens da nossa aplicação.
Para isso basta criarmos um arquivo chamado ::messages.properties:: e disponibiliza-lo no classpath da nossa aplicação ( WEB-INF/classes ).
O conteúdo desse arquivo são várias linhas compostas por um conjunto de chave/valor, como por exemplo:

[code]
campo.nomeUsuario = Nome de Usuário
campo.senha = Senha
[/code]

Até então está fácil, mas e se quisermos criar esses arquivos para várias linguas, como por exemplo, inglês? Simples, basta criarmos um outro arquivo
.properties chamado messages_en.properties. Repare no sufixo ::_en:: no nome do arquivo. Isso indica que quando o usuário acessar sua aplicação
através de uma máquina configurada com locale em inglês as mensagens desse arquivo serão utilizadas. O conteúdo desse arquivo então ficaria:

[code]
campo.nomeUsuario = Username
campo.senha = Password
[/code]

Repare que as chaves são mantidas, mudando apenas o valor para a língua escolhida.

Para usar essas mensagens em seus arquivos .jsp, você pode utilizar a JSTL. Dessa forma, o código ficaria:

[code]
<%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %>
<html>
	<body>
		<fmt:message key="campo.usuario" /> <input name="usuario.nomeUsuario" />
		
		<br />
		
		<fmt:message key="campo.senha" /> <input type="password" name="usuario.senha" />
		
		<input type="submit" />
	</body>
</html>
[/code]

[section WEB-INF/lib]

[section blank-project]

temos que ter um blank-project que e' so descompactar